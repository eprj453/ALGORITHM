# 순환식



[1, 3, 10, 5]

[6, 5, 5, 1]

[10, 9, 7, 5]

[5, 6, 7, 4]



## 동쪽과 남쪽으로만 이동할 때, (0,0)에서 최단 경로로 (3, 3)까지 가는 방법은?

dijkstra 알고리즘으로 풀수도 있다.

그러나 방향이 단순하고 Node의 갯수가 많은 경우에는 순환식을 세워서 푸는 것이 더 좋을수 있다.

```
arr = [[1, 3, 10, 5], [6, 5, 5, 1], [10, 9, 7, 5],[5, 6, 7, 4]]

L(i, j) -> (0, 0)에서 (i, j)까지 이르는 최소합


		-> m(i, j) if i == 0 or j == 0
L(i, j) -> L(i-1, j) + m(i, j) if j == 0
		-> L(i, j-1) + m(i, j) if i == 0
		-> min(L(i-1, j), L(i, j-1)) + m(i, j)
```

다음과 같은 점화식을 세울 수 있다.

모든 케이스의 순환식을 세우는 것이 중요하다.

슈도 코드로 해법을 적어보면,

```
def dp(i, j):
	if i == 0 and j == 0:
		return arr[0][0] 
	elif i == 0:
		return dp[i][j-1] + m[i][j]
	elif j == 0:
		return dp[i-1][j] + m[i][j]
	else:
		return min(dp[i-1][j], dp[i][j-1]) + m[i][j]
```

너무 비효율적이다. 계산 중복이 굉장히 심하다.

메모이제이션이나 반복문으로 처리하면 효과적으로 처리할 수 있다.

행 우선으로 순회할 경우 바로 위의 값과 바로 왼쪽의 값이 항상 먼저 계산되므로 항상 최소값을 가질 수 있다.

시간복잡도는 O(n^2)

```python
for i in range(0, n):
    L[0][i] = inf
    L[i][0] = inf

for i in range(1, n):
	for j in range(1, n):
        if i == 1 or j == 1:
            L[i][j] = m[i][j]
        else:
            L[i][j] = min(L[i-1][j], L[i][j-1]) + m[i][j]
```





## 합이 최소가 되는 경로를 찾으려면?

경로를 저장할 2차원 배열을 하나 더 할당한 뒤에,

값이 갱신될때마다 갱신되는 값이 위치한 인덱스를 저장한다.





## Optimal Substructure

- 일반적으로  최적화 문제나 카운팅 문제에 사용된다(값을 구하는 문제).
- 주어진 문제에 대한 순환식을 정의한다. Dynamic Programming의 핵심
- 순환식을 memoization 또는 bottom-up 방식으로 푼다.
- 